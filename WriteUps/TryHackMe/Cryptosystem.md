# Cryptosystem Walkthrough

## Intro
Welcome to the Cryptosystem challenge, here is the link to the [room](https://tryhackme.com/room/hfb1cryptosystem) on TryHackMe.
In this ctf we will have to analyze a script, understand how the data is being encrypted and revert the process to recover the flag.

"*We intercepted a communication between Cipher and some 3 associates: Rivest, Shamir and Adleman. We were only able to retrieve a file.
ORDER: Get the secret key from the recovered file.*"

Let's begin!

<br/>
<br/>

## The Challenge
Here is the provided file, a python scirpt:
```python
from Crypto.Util.number import *
from flag import FLAG

def primo(n):
    n += 2 if n & 1 else 1
    while not isPrime(n):
        n += 2
    return n

p = getPrime(1024)
q = primo(p)
n = p * q
e = 0x10001
d = inverse(e, (p-1) * (q-1))
c = pow(bytes_to_long(FLAG.encode()), e, n)
#c = 3591116664311986976882299385598135447435246460706500887241769555088416359682787844532414943573794993699976035504884662834956846849863199643104254423886040489307177240200877443325036469020737734735252009890203860703565467027494906178455257487560902599823364571072627673274663460167258994444999732164163413069705603918912918029341906731249618390560631294516460072060282096338188363218018310558256333502075481132593474784272529318141983016684762611853350058135420177436511646593703541994904632405891675848987355444490338162636360806437862679321612136147437578799696630631933277767263530526354532898655937702383789647510
#n = 15956250162063169819282947443743274370048643274416742655348817823973383829364700573954709256391245826513107784713930378963551647706777479778285473302665664446406061485616884195924631582130633137574953293367927991283669562895956699807156958071540818023122362163066253240925121801013767660074748021238790391454429710804497432783852601549399523002968004989537717283440868312648042676103745061431799927120153523260328285953425136675794192604406865878795209326998767174918642599709728617452705492122243853548109914399185369813289827342294084203933615645390728890698153490318636544474714700796569746488209438597446475170891
```

Looking at it we can understand that we are dealing with some RSA encryption.
Let's take a closer look:
- `p` is a 1024-bit prime number, generated by `getPrime(1024)`
- `q` is another prime number, found by the function `primo(n)`, which ensures it is the next prime greater than `p`
- `n` is the product of `p` and `q`, and is used as the modulus in RSA
- `e` is the public exponent, set to `0x10001`
- `d` is the private key, calculated as the modular inverse of `e` modulo the totient of $n ((p-1) * (q-1))$
- `c` is the ciphertext that results from encrypting the flag `FLAG` using the public key (`e`, `n`).
	- Also the flag is encoded as bytes and then encrypted with the public exponent `e` and the modulus `n`.

An important thing to note with RSA is that all it security depends on the factorization of prime numbers, this means that we should choose `p` and `q` as large as possible to increase the strength.
But, on the other side if we choose 2 small values we can reconstruct the values by factorizing `n`, this will work because with 2 sufficiently small numbers or with enough processing power we can revert the process in a "decent" time.
- [here](https://en.wikipedia.org/wiki/Fermat%27s_factorization_method) is an expansion on the matter i found on Wikipedia (the mathematical side for those interested)

Little quick explanation here:
Per Fermat ‚ÄúAny number `n`  that is a product of two numbers can be written as the difference between two squares.‚Äù
Which can be written as:  $n = x¬≤ - y¬≤$
That again can be decomposed as  $n=(x‚àíy)(x+y)$

So if we can find `x` and y such that $x^2 - n = y^2$ then `x+y` and `x-y` will be factors of `n`.
Since `p` and `q` are primes and are close to each other, this method can be quite cost-effective.

In the context of RSA, the totient function $œÜ(n)$ is crucial for calculating the private key `d`.
- The totient $œÜ(n)$ is used because it counts how many numbers from 1 to `n‚àí1` are coprime with `n`. When `n` is a product of two primes, the formula for $œÜ(n)$ simplifies to $(p‚àí1)(q‚àí1)$, because each prime factor `p` and `q` contributes to reducing the number of coprime numbers below `n`.

Anyway we do not have to do any of this calcs by hand, on Python there are crypto modules exactly for this.

So you have guessed right, time to build our script to:
- Use Fermat theorem factor `n` and find `p` and `q`
- Calculate the totient of `n` which is $œÜ(n)=(p‚àí1)(q‚àí1)$ 
- Now times to calculate $d = inverse(e, œÜ)$
- At this point we decrypt the flag $m = pow(c, d, n)$
- Finally decode the flag from `m`

Let's first create a virtual environment and install dependencies:
```bash
python3 -m venv venv; source venv/bin/activate
pip3 install pycryptodome
```

Since i'm not used to build scripts to revert RSA i needed some help, after some iteration with AI i managed to get this working one:

**Note:** if you plan to make your own with any AI help i suggest giving it precise commands. In the initial iterations where i gave it free "will" to construct it was a disaster. I found out that giving the exact steps i listed previously worked much better and only had to do a couple of fixes to make it work right. I guess "prompt engineering" is not dead, yet.

```python
#!/usr/bin/env python3
# A script to reverse RSA encryption

from Crypto.Util.number import *
import math

# Step 1: Fermat's Factorization method to factorize n
def fermat_factorization(n):
    # Start from the smallest x greater than or equal to the square root of n
    x = math.isqrt(n)
    while True:
        # Calculate y^2 = x^2 - n
        y_squared = x * x - n
        
        # Check if y^2 is a perfect square
        y = math.isqrt(y_squared)
        if y * y == y_squared:
            # If y^2 is a perfect square, we have found factors
            p = x - y
            q = x + y
            return p, q
        
        # Otherwise, increment x and try again
        x += 1

# Step 2: Calculate Euler's Totient (œÜ(n)) = (p-1)(q-1)
def calculate_totient(p, q):
    return (p - 1) * (q - 1)

# Step 3: Calculate the private key d using the modular inverse of e modulo œÜ(n)
def calculate_private_key(e, phi):
    return inverse(e, phi)

# Step 4: Decrypt the ciphertext using the private key d
def decrypt(c, d, n):
    return long_to_bytes(pow(c, d, n))

# The ciphertext 
c = 3591116664311986976882299385598135447435246460706500887241769555088416359682787844532414943573794993699976035504884662834956846849863199643104254423886040489307177240200877443325036469020737734735252009890203860703565467027494906178455257487560902599823364571072627673274663460167258994444999732164163413069705603918912918029341906731249618390560631294516460072060282096338188363218018310558256333502075481132593474784272529318141983016684762611853350058135420177436511646593703541994904632405891675848987355444490338162636360806437862679321612136147437578799696630631933277767263530526354532898655937702383789647510
n = 15956250162063169819282947443743274370048643274416742655348817823973383829364700573954709256391245826513107784713930378963551647706777479778285473302665664446406061485616884195924631582130633137574953293367927991283669562895956699807156958071540818023122362163066253240925121801013767660074748021238790391454429710804497432783852601549399523002968004989537717283440868312648042676103745061431799927120153523260328285953425136675794192604406865878795209326998767174918642599709728617452705492122243853548109914399185369813289827342294084203933615645390728890698153490318636544474714700796569746488209438597446475170891
e = 0x10001  # Public exponent

# Step 1: Factorize n using Fermat's Factorization
p, q = fermat_factorization(n)
print(f"Found factors: p = {p}, q = {q}")

# Step 2: Calculate the totient 
phi = calculate_totient(p, q)
print(f"Totient œÜ(n) = {phi}")

# Step 3: Calculate the private key d
d = calculate_private_key(e, phi)
print(f"Private key d = {d}")

# Step 4: Decrypt the ciphertext
decrypted_message = decrypt(c, d, n)
print(f"Decrypted flag: {decrypted_message.decode()}")
```

<br/>
<br/>

Congratulations you have successfully uncovered the encrypted flag and practiced your cryptography skills to break RSA.

Hope you had fun following along and completing the challenge.
Catch you in the next CTF üòÉ 
